<!DOCTYPE html>
<html>

<head>
    <title>test editor app</title>
    <script src="../lib/paper-full.min.js"></script>
    <script src="../lib/dat.gui.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body,
        html {
            height: 100%;
            background-color: #222;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <script type="text/javascript">
        window.onload = _ => {
            paper.install(window);
            paper.setup('canvas');
            window.onresize();
            setupGUI();
        }

        var layers = [];
        var params = {
            activeTool: 'draw',
            previousActiveTool: 'draw',

            activeLayer: 'layer0',
            fgcolor1: '#ff0000',
            fgcolor2: '#00ff00',
            bgcolor1: '#0000ff',
            bgcolor2: '#ffff00',
            clearCanvas: _ => { },
            addLayer: _ => { },

        };

        setupGUI = _ => {
            //clear gui if it exists
            if (gui) {
                gui.destroy();
            }
            // Build the GUI
            //create a params object with activeTool, clearCanvas


            ////create a dat.gui
            var gui = new dat.GUI();
            //actions
            //mode
            //tool
            //layer
            //create a folder for the params 
            var actionsFolder = gui.addFolder('Actions');
            var modeFolder = gui.addFolder('Mode');
            var toolFolder = gui.addFolder('Tool');
            var layerFolder = gui.addFolder('Layer');




            toolFolder.add(params, 'activeTool',
                ['draw', 'edit', 'select', 'erase']).name('mode').onChange(value => {
                    params.previousActiveTool = value;
                    console.log(params.activeTool + ' ' + params.previousActiveTool);
                }).listen();
            //add color picker for foreground color
            toolFolder.addColor(params, 'fgcolor1').name('fgcolor1');
            toolFolder.addColor(params, 'fgcolor2').name('fgcolor2');
            toolFolder.addColor(params, 'bgcolor1').name('bgcolor1');
            toolFolder.addColor(params, 'bgcolor2').name('bgcolor2');

            actionsFolder.add(params, 'clearCanvas').name('clear canvas').onChange(_ => {
                paper.project.activeLayer.clear();
            });

            //add a button to the gui to add a new layer
            layerFolder.add(params, 'addLayer').name('add layer').onChange(_ => {
                var newLayer = new paper.Layer({
                    name: 'layer' + (layers.length),
                    visible: true,
                    opacity: 1,
                    locked: false,
                    color: '#ff0000'
                });

                layers.push(newLayer);
                newLayer.activate();

                // console.log(layers.map(l => l.name));
                layerlist.remove();
                layerlist = layerFolder.add(params, 'activeLayer',
                    layers.map(l => l.name)).name('layer')
                    .onChange(updateActiveLayer).listen();
            });

            //update the dropdown menu choices with the names of the layers
            const updateLayerList = name => {
                paper.project.activeLayer = layers.find(l => l.name == name);
                let l = layers.find(l => l.name === value);
                console.log(value + " " + l.name + " " + paper.project.activeLayer.name);

            };

            const updateActiveLayer = name => {
                let newactivelayer = layers.find(l => l.name === name);
                newactivelayer.activate();
                console.log(newactivelayer.name + " " + paper.project.activeLayer.name);
            }

            const layerlist = layerFolder.add(params, 'activeLayer',
                paper.project.layers.map(l => l.name)).
                name('layer').onChange(updateActiveLayer).listen();

            // gui.domElement.style.display = 'none';
            //setup keybinding for alt+v or esc to toggle dat.gui visibility on/off
            document.addEventListener('keydown', e => {
                if ((e.keyCode == 27) || (e.keyCode == 86 && e.altKey)) {
                    gui.domElement.style.display = gui.domElement.style.display == 'none' ? 'block' : 'none';
                }
            });


        };

        //on resize window rebuild the paper project
        window.onresize = _ => {
            paper.view.viewSize = new paper.Size(window.innerWidth, window.innerHeight);
            setupPaper();

            setupDrawingTools();
            sketch1();
        };

        const setupPaper = _ => {
            //clear the paper project
            paper.project.clear();
            layers = [];
            layers.push(new paper.Layer({
                name: 'layer0',
                visible: true,
                opacity: 1,
                locked: false,
                color: 'none'
            }));

            layers.push(new paper.Layer({
                name: 'layer1',
                visible: true,
                opacity: 1,
                locked: false,
                color: '#ffff00'
            }));



        }

        ////////////////////////////////////////////////////////////////////////////////
        //// draw background grid
        const drawBackgroundGrid = (n = 20, color1 = 'red', color2 = 'lightblue') => {
            //draw a square n x n grid with thin black lines on the background layer
            //const n = 20;
            console.log(n);
            const viewsize = paper.view.size;
            const grid = new paper.Path.Rectangle({
                rectangle: [n, n,
                    paper.view.size.width - 2 * n, paper.view.size.height - 2 * n],
                fillColor: color1,
                strokeColor: 'none',
                opacity: .5
            })
            let aspect = paper.view.size.width / paper.view.size.height;
            aspect = 1;
            let gridstep = { x: n, y: n };
            let nsteps = Math.max(paper.view.size.width, paper.view.size.height) /
                Math.min(gridstep.x, gridstep.y);

            for (let i = 0; i < nsteps; i++) {
                let x = i * gridstep.x;
                let y = aspect * i * gridstep.y;
                let line = new paper.Path.Line({
                    from: [x, 0],
                    to: [x, paper.view.size.height],
                    strokeColor: color2,
                    strokeWidth: 1
                });
                // line.sendToFront();
                let line2 = new paper.Path.Line({
                    from: [0, y],
                    to: [paper.view.size.width, y],
                    strokeColor: color2,
                    strokeWidth: 1
                });
                //line2.sendToBack();
            }

        }
        ////////////////////////////////////////////////////////////////////////////////
        //// setup drawing tools
        const setupDrawingTools = _ => {
            //create a new tool for drawing
            var drawTool = new paper.Tool();
            drawTool.minDistance = 10;
            var drawToolPath;
            //keybdinging for q key to toggle between draw and edit mode


            // document.addEventListener('keydown', e => {
            //     if (e.key == 'q') {

            //         params.activeTool = 'select';
            //         console.log('qdown:' + params.activeTool + ' ' + params.previousActiveTool);

            //     } else if (e.key == 'd') {
            //         params.activeTool = 'draw';
            //     }

            // });

            // //add document keybinding for q key release to restore previous active tool

            // document.addEventListener('keyup', e => {
            //     if (e.key == 'q') {
            //         console.log('qup:' + params.activeTool + ' ' + params.previousActiveTool);

            //         params.activeTool = params.previousActiveTool;


            //     }
            // });
            

            drawTool.onKeyDown = e => {
                params.previousActiveTool=params.activeTool;
                if (e.key == 'q') {
                    params.activeTool = 'select';
                } else if (e.key == 'd') {
                    params.activeTool = 'draw';
                } else if (e.key == 'x') {
                    params.activeTool = 'erase';
                }
            }

            drawTool.onKeyUp = e => {
                params.activeTool=params.previousActiveTool;
            }



            drawTool.onMouseDown = e => {
                if (params.activeTool == 'draw') {
                    if (drawToolPath) drawToolPath.selected = false;

                    drawToolPath = new paper.Path();
                    drawToolPath.strokeColor = params.fgcolor1;
                    drawToolPath.fillColor = params.bgcolor1;
                    drawToolPath.strokeWidth = 1;
                    drawToolPath.fullySelected = true;
                    drawToolPath.closed = false;
                } else if (params.activeTool == 'select') {

                    if (drawToolPath) {
                        if(e.item) {
                            e.item.selected = !e.item.selected;
                        }
                        // drawToolPath.selected = !drawToolPath.selected;
                        // if(drawToolPath.selected){
                        //     selectedPath = drawToolPath;
                        // }
                    }
                }
            };

            drawTool.onMouseDrag = e => {
                if (params.activeTool == 'draw') {
                    drawToolPath.add(e.point);
                }

            };

            drawTool.onMouseMove = e => {
              //  if (params.activeTool == 'draw') {
                    // project.activeLayer.selected = false;
                    // if (e.item) {
                    //     e.item.selected = true;
                    //     selectedPath = event.item;
                    // } else {
                    //     selectedPath = null;
                    // }

                //}
            }

            //loop over all selected items in the active layer and remove them
            drawTool.onKeyDown = e => {
                if (e.key == 'backspace') {
                    paper.project.selectedItems.array.forEach(e => {
                        e.remove();
                        
                    });
                }
            }

            //remove all selected items in the active layer
            drawTool.onKeyDown = e => {
                if (e.key == 'delete') {
                    //loop over all selected items in the active layer and remove them

                }
            }
            drawTool.onMouseUp = e => {
                if (params.activeTool == 'draw') {

                    drawToolPath.add(e.point);
                    //smooth path by 90%
                    //drawToolPath.smooth();
                    drawToolPath.closed = true;

                    drawToolPath.smooth({ type: 'continuous', factor: .9 });
                    drawToolPath.simplify();
                    //  drawToolPath.selected = true;
                    // drawToolPath = null;
                } else if (params.activeTool == 'erase') {
                    console.log('erase');
                    if (e.item) e.item.remove();
                }

            };
        }
        /////////////////////////////////
        //// sketch 1
        const sketch1 = _ => {
            layers[0].activate();
            drawBackgroundGrid(25, 'blue');
            layers[1].activate();
            drawBackgroundGrid(100, 'yellow');

        }

    </script>
</body>

</html>